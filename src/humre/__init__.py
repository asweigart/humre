"""Humre
By Al Sweigart al@inventwithpython.com

A human-readable regular expression module for Python."""

# TODO - add functionality to parse regex strings and create the humre code for it.
# TODO - Add inline flags like '(?i)'

import re, itertools, functools


try:
    from typing import ParamSpecArgs
except ImportError:
    pass  # Do nothing if run with a version of Python that doesn't have type hints.

__version__ = '0.1.3'

DIGIT = r'\d'
WORD = r'\w'
WHITESPACE = r'\s'
NONDIGIT = r'\D'
NONWORD = r'\W'
NONWHITESPACE = r'\S'

BOUNDARY = r'\b'
# IGNORE_DIRECTIVE = '(?i)'


# Constants copied from the re module:
# Changed in version 3.6: Flag constants are now instances of RegexFlag, which is a subclass of enum.IntFlag.
A = re.A
ASCII = re.ASCII
DEBUG = re.DEBUG
I = re.I
IGNORECASE = re.IGNORECASE
L = re.L
LOCALE = re.LOCALE
M = re.M
MULTILINE = re.MULTILINE
NOFLAG = 0  # re.NOFLAG  # New in 3.11
S = re.S
DOTALL = re.DOTALL
X = re.X
VERBOSE = re.VERBOSE

# Built-in Humre character classes:

# To avoid possible rendering issues with code editors, instead of
# copy/pasting the unicode characters directly into the source, I'm
# leaving them as integer ranges that get converted into the strings
# by _getRegexCharacterClassStringFromCodePointRanges().
# This part of the code is dedicated to Python core dev Åukasz Langa, who
# is tired of having his name not be processed correctly by software.
# https://youtu.be/7m5JA3XaZ4k
def _getRegexCharacterClassStringFromCodePointRanges(tupleOfRanges):
    # A helper function to convert integer ranges into regex character class strings.
    regexStr = []
    for startRangeCodePoint, endRangeCodePoint in tupleOfRanges:
        if startRangeCodePoint == endRangeCodePoint:
            # This is not a range, just a single code point, so don't use a hyphen.
            regexStr.append(chr(startRangeCodePoint))
        else:
            regexStr.append(chr(startRangeCodePoint) + '-' + chr(endRangeCodePoint))
    return ''.join(regexStr)


# fmt: off
# These tuple of tuples of two integers are ranges of unicode code points.
# We pass these to _getRegexCharacterClassStringFromCodePointRanges() to
# get a string to put inside a regex character class, like [a-z] but
# much, much more specific.
# The numbers come from testing every character against Python's islower(),
# isupper(), isalpha(), and isnumeric() string methods.
_lowercaseCharClass = _getRegexCharacterClassStringFromCodePointRanges(
    (
        (97, 122), (170, 170), (181, 181), (186, 186), (223, 246), (248, 255), (257, 257), (259, 259), (261, 261), (263, 263), (265, 265), (267, 267), (269, 269), (271, 271), (273, 273), (275, 275), (277, 277), (279, 279), (281, 281), (283, 283), (285, 285), (287, 287), (289, 289), (291, 291), (293, 293), (295, 295), (297, 297), (299, 299), (301, 301), (303, 303), (305, 305), (307, 307), (309, 309), (311, 312), (314, 314), (316, 316), (318, 318), (320, 320), (322, 322), (324, 324), (326, 326), (328, 329), (331, 331), (333, 333), (335, 335), (337, 337), (339, 339), (341, 341), (343, 343), (345, 345), (347, 347), (349, 349), (351, 351), (353, 353), (355, 355), (357, 357), (359, 359), (361, 361), (363, 363), (365, 365), (367, 367), (369, 369), (371, 371), (373, 373), (375, 375), (378, 378), (380, 380), (382, 384), (387, 387), (389, 389), (392, 392), (396, 397), (402, 402), (405, 405), (409, 411), (414, 414), (417, 417), (419, 419), (421, 421), (424, 424), (426, 427), (429, 429), (432, 432), (436, 436), (438, 438), (441, 442), (445, 447), (454, 454), (457, 457), (460, 460), (462, 462), (464, 464), (466, 466), (468, 468), (470, 470), (472, 472), (474, 474), (476, 477), (479, 479), (481, 481), (483, 483), (485, 485), (487, 487), (489, 489), (491, 491), (493, 493), (495, 496), (499, 499), (501, 501), (505, 505), (507, 507), (509, 509), (511, 511), (513, 513), (515, 515), (517, 517), (519, 519), (521, 521), (523, 523), (525, 525), (527, 527), (529, 529), (531, 531), (533, 533), (535, 535), (537, 537), (539, 539), (541, 541), (543, 543), (545, 545), (547, 547), (549, 549), (551, 551), (553, 553), (555, 555), (557, 557), (559, 559), (561, 561), (563, 569), (572, 572), (575, 576), (578, 578), (583, 583), (585, 585), (587, 587), (589, 589), (591, 659), (661, 696), (704, 705), (736, 740), (837, 837), (881, 881), (883, 883), (887, 887), (890, 893), (912, 912), (940, 974), (976, 977), (981, 983), (985, 985), (987, 987), (989, 989), (991, 991), (993, 993), (995, 995), (997, 997), (999, 999), (1001, 1001), (1003, 1003), (1005, 1005), (1007, 1011), (1013, 1013), (1016, 1016), (1019, 1020), (1072, 1119), (1121, 1121), (1123, 1123), (1125, 1125), (1127, 1127), (1129, 1129), (1131, 1131), (1133, 1133), (1135, 1135), (1137, 1137), (1139, 1139), (1141, 1141), (1143, 1143), (1145, 1145), (1147, 1147), (1149, 1149), (1151, 1151), (1153, 1153), (1163, 1163), (1165, 1165), (1167, 1167), (1169, 1169), (1171, 1171), (1173, 1173), (1175, 1175), (1177, 1177), (1179, 1179), (1181, 1181), (1183, 1183), (1185, 1185), (1187, 1187), (1189, 1189), (1191, 1191), (1193, 1193), (1195, 1195), (1197, 1197), (1199, 1199), (1201, 1201), (1203, 1203), (1205, 1205), (1207, 1207), (1209, 1209), (1211, 1211), (1213, 1213), (1215, 1215), (1218, 1218), (1220, 1220), (1222, 1222), (1224, 1224), (1226, 1226), (1228, 1228), (1230, 1231), (1233, 1233), (1235, 1235), (1237, 1237), (1239, 1239), (1241, 1241), (1243, 1243), (1245, 1245), (1247, 1247), (1249, 1249), (1251, 1251), (1253, 1253), (1255, 1255), (1257, 1257), (1259, 1259), (1261, 1261), (1263, 1263), (1265, 1265), (1267, 1267), (1269, 1269), (1271, 1271), (1273, 1273), (1275, 1275), (1277, 1277), (1279, 1279), (1281, 1281), (1283, 1283), (1285, 1285), (1287, 1287), (1289, 1289), (1291, 1291), (1293, 1293), (1295, 1295), (1297, 1297), (1299, 1299), (1301, 1301), (1303, 1303), (1305, 1305), (1307, 1307), (1309, 1309), (1311, 1311), (1313, 1313), (1315, 1315), (1317, 1317), (1319, 1319), (1321, 1321), (1323, 1323), (1325, 1325), (1327, 1327), (1376, 1416), (4304, 4346), (4349, 4351), (5112, 5117), (7296, 7304), (7424, 7615), (7681, 7681), (7683, 7683), (7685, 7685), (7687, 7687), (7689, 7689), (7691, 7691), (7693, 7693), (7695, 7695), (7697, 7697), (7699, 7699), (7701, 7701), (7703, 7703), (7705, 7705), (7707, 7707), (7709, 7709), (7711, 7711), (7713, 7713), (7715, 7715), (7717, 7717), (7719, 7719), (7721, 7721), (7723, 7723), (7725, 7725), (7727, 7727), (7729, 7729), (7731, 7731), (7733, 7733), (7735, 7735), (7737, 7737), (7739, 7739), (7741, 7741), (7743, 7743), (7745, 7745), (7747, 7747), (7749, 7749), (7751, 7751), (7753, 7753), (7755, 7755), (7757, 7757), (7759, 7759), (7761, 7761), (7763, 7763), (7765, 7765), (7767, 7767), (7769, 7769), (7771, 7771), (7773, 7773), (7775, 7775), (7777, 7777), (7779, 7779), (7781, 7781), (7783, 7783), (7785, 7785), (7787, 7787), (7789, 7789), (7791, 7791), (7793, 7793), (7795, 7795), (7797, 7797), (7799, 7799), (7801, 7801), (7803, 7803), (7805, 7805), (7807, 7807), (7809, 7809), (7811, 7811), (7813, 7813), (7815, 7815), (7817, 7817), (7819, 7819), (7821, 7821), (7823, 7823), (7825, 7825), (7827, 7827), (7829, 7837), (7839, 7839), (7841, 7841), (7843, 7843), (7845, 7845), (7847, 7847), (7849, 7849), (7851, 7851), (7853, 7853), (7855, 7855), (7857, 7857), (7859, 7859), (7861, 7861), (7863, 7863), (7865, 7865), (7867, 7867), (7869, 7869), (7871, 7871), (7873, 7873), (7875, 7875), (7877, 7877), (7879, 7879), (7881, 7881), (7883, 7883), (7885, 7885), (7887, 7887), (7889, 7889), (7891, 7891), (7893, 7893), (7895, 7895), (7897, 7897), (7899, 7899), (7901, 7901), (7903, 7903), (7905, 7905), (7907, 7907), (7909, 7909), (7911, 7911), (7913, 7913), (7915, 7915), (7917, 7917), (7919, 7919), (7921, 7921), (7923, 7923), (7925, 7925), (7927, 7927), (7929, 7929), (7931, 7931), (7933, 7933), (7935, 7943), (7952, 7957), (7968, 7975), (7984, 7991), (8000, 8005), (8016, 8023), (8032, 8039), (8048, 8061), (8064, 8071), (8080, 8087), (8096, 8103), (8112, 8116), (8118, 8119), (8126, 8126), (8130, 8132), (8134, 8135), (8144, 8147), (8150, 8151), (8160, 8167), (8178, 8180), (8182, 8183), (8305, 8305), (8319, 8319), (8336, 8348), (8458, 8458), (8462, 8463), (8467, 8467), (8495, 8495), (8500, 8500), (8505, 8505), (8508, 8509), (8518, 8521), (8526, 8526), (8560, 8575), (8580, 8580), (9424, 9449), (11312, 11358), (11361, 11361), (11365, 11366), (11368, 11368), (11370, 11370), (11372, 11372), (11377, 11377), (11379, 11380), (11382, 11389), (11393, 11393), (11395, 11395), (11397, 11397), (11399, 11399), (11401, 11401), (11403, 11403), (11405, 11405), (11407, 11407), (11409, 11409), (11411, 11411), (11413, 11413), (11415, 11415), (11417, 11417), (11419, 11419), (11421, 11421), (11423, 11423), (11425, 11425), (11427, 11427), (11429, 11429), (11431, 11431), (11433, 11433), (11435, 11435), (11437, 11437), (11439, 11439), (11441, 11441), (11443, 11443), (11445, 11445), (11447, 11447), (11449, 11449), (11451, 11451), (11453, 11453), (11455, 11455), (11457, 11457), (11459, 11459), (11461, 11461), (11463, 11463), (11465, 11465), (11467, 11467), (11469, 11469), (11471, 11471), (11473, 11473), (11475, 11475), (11477, 11477), (11479, 11479), (11481, 11481), (11483, 11483), (11485, 11485), (11487, 11487), (11489, 11489), (11491, 11492), (11500, 11500), (11502, 11502), (11507, 11507), (11520, 11557), (11559, 11559), (11565, 11565), (42561, 42561), (42563, 42563), (42565, 42565), (42567, 42567), (42569, 42569), (42571, 42571), (42573, 42573), (42575, 42575), (42577, 42577), (42579, 42579), (42581, 42581), (42583, 42583), (42585, 42585), (42587, 42587), (42589, 42589), (42591, 42591), (42593, 42593), (42595, 42595), (42597, 42597), (42599, 42599), (42601, 42601), (42603, 42603), (42605, 42605), (42625, 42625), (42627, 42627), (42629, 42629), (42631, 42631), (42633, 42633), (42635, 42635), (42637, 42637), (42639, 42639), (42641, 42641), (42643, 42643), (42645, 42645), (42647, 42647), (42649, 42649), (42651, 42653), (42787, 42787), (42789, 42789), (42791, 42791), (42793, 42793), (42795, 42795), (42797, 42797), (42799, 42801), (42803, 42803), (42805, 42805), (42807, 42807), (42809, 42809), (42811, 42811), (42813, 42813), (42815, 42815), (42817, 42817), (42819, 42819), (42821, 42821), (42823, 42823), (42825, 42825), (42827, 42827), (42829, 42829), (42831, 42831), (42833, 42833), (42835, 42835), (42837, 42837), (42839, 42839), (42841, 42841), (42843, 42843), (42845, 42845), (42847, 42847), (42849, 42849), (42851, 42851), (42853, 42853), (42855, 42855), (42857, 42857), (42859, 42859), (42861, 42861), (42863, 42872), (42874, 42874), (42876, 42876), (42879, 42879), (42881, 42881), (42883, 42883), (42885, 42885), (42887, 42887), (42892, 42892), (42894, 42894), (42897, 42897), (42899, 42901), (42903, 42903), (42905, 42905), (42907, 42907), (42909, 42909), (42911, 42911), (42913, 42913), (42915, 42915), (42917, 42917), (42919, 42919), (42921, 42921), (42927, 42927), (42933, 42933), (42935, 42935), (42937, 42937), (42939, 42939), (42941, 42941), (42943, 42943), (42947, 42947), (42952, 42952), (42954, 42954), (42998, 42998), (43000, 43002), (43824, 43866), (43868, 43880), (43888, 43967), (64256, 64262), (64275, 64279), (65345, 65370), (66600, 66639), (66776, 66811), (68800, 68850), (71872, 71903), (93792, 93823), (119834, 119859), (119886, 119892), (119894, 119911), (119938, 119963), (119990, 119993), (119995, 119995), (119997, 120003), (120005, 120015), (120042, 120067), (120094, 120119), (120146, 120171), (120198, 120223), (120250, 120275), (120302, 120327), (120354, 120379), (120406, 120431), (120458, 120485), (120514, 120538), (120540, 120545), (120572, 120596), (120598, 120603), (120630, 120654), (120656, 120661), (120688, 120712), (120714, 120719), (120746, 120770), (120772, 120777), (120779, 120779), (125218, 125251),
    )
)
_uppercaseCharClass = _getRegexCharacterClassStringFromCodePointRanges(
    (
        (65, 90), (192, 214), (216, 222), (256, 256), (258, 258), (260, 260), (262, 262), (264, 264), (266, 266), (268, 268), (270, 270), (272, 272), (274, 274), (276, 276), (278, 278), (280, 280), (282, 282), (284, 284), (286, 286), (288, 288), (290, 290), (292, 292), (294, 294), (296, 296), (298, 298), (300, 300), (302, 302), (304, 304), (306, 306), (308, 308), (310, 310), (313, 313), (315, 315), (317, 317), (319, 319), (321, 321), (323, 323), (325, 325), (327, 327), (330, 330), (332, 332), (334, 334), (336, 336), (338, 338), (340, 340), (342, 342), (344, 344), (346, 346), (348, 348), (350, 350), (352, 352), (354, 354), (356, 356), (358, 358), (360, 360), (362, 362), (364, 364), (366, 366), (368, 368), (370, 370), (372, 372), (374, 374), (376, 377), (379, 379), (381, 381), (385, 386), (388, 388), (390, 391), (393, 395), (398, 401), (403, 404), (406, 408), (412, 413), (415, 416), (418, 418), (420, 420), (422, 423), (425, 425), (428, 428), (430, 431), (433, 435), (437, 437), (439, 440), (444, 444), (452, 452), (455, 455), (458, 458), (461, 461), (463, 463), (465, 465), (467, 467), (469, 469), (471, 471), (473, 473), (475, 475), (478, 478), (480, 480), (482, 482), (484, 484), (486, 486), (488, 488), (490, 490), (492, 492), (494, 494), (497, 497), (500, 500), (502, 504), (506, 506), (508, 508), (510, 510), (512, 512), (514, 514), (516, 516), (518, 518), (520, 520), (522, 522), (524, 524), (526, 526), (528, 528), (530, 530), (532, 532), (534, 534), (536, 536), (538, 538), (540, 540), (542, 542), (544, 544), (546, 546), (548, 548), (550, 550), (552, 552), (554, 554), (556, 556), (558, 558), (560, 560), (562, 562), (570, 571), (573, 574), (577, 577), (579, 582), (584, 584), (586, 586), (588, 588), (590, 590), (880, 880), (882, 882), (886, 886), (895, 895), (902, 902), (904, 906), (908, 908), (910, 911), (913, 929), (931, 939), (975, 975), (978, 980), (984, 984), (986, 986), (988, 988), (990, 990), (992, 992), (994, 994), (996, 996), (998, 998), (1000, 1000), (1002, 1002), (1004, 1004), (1006, 1006), (1012, 1012), (1015, 1015), (1017, 1018), (1021, 1071), (1120, 1120), (1122, 1122), (1124, 1124), (1126, 1126), (1128, 1128), (1130, 1130), (1132, 1132), (1134, 1134), (1136, 1136), (1138, 1138), (1140, 1140), (1142, 1142), (1144, 1144), (1146, 1146), (1148, 1148), (1150, 1150), (1152, 1152), (1162, 1162), (1164, 1164), (1166, 1166), (1168, 1168), (1170, 1170), (1172, 1172), (1174, 1174), (1176, 1176), (1178, 1178), (1180, 1180), (1182, 1182), (1184, 1184), (1186, 1186), (1188, 1188), (1190, 1190), (1192, 1192), (1194, 1194), (1196, 1196), (1198, 1198), (1200, 1200), (1202, 1202), (1204, 1204), (1206, 1206), (1208, 1208), (1210, 1210), (1212, 1212), (1214, 1214), (1216, 1217), (1219, 1219), (1221, 1221), (1223, 1223), (1225, 1225), (1227, 1227), (1229, 1229), (1232, 1232), (1234, 1234), (1236, 1236), (1238, 1238), (1240, 1240), (1242, 1242), (1244, 1244), (1246, 1246), (1248, 1248), (1250, 1250), (1252, 1252), (1254, 1254), (1256, 1256), (1258, 1258), (1260, 1260), (1262, 1262), (1264, 1264), (1266, 1266), (1268, 1268), (1270, 1270), (1272, 1272), (1274, 1274), (1276, 1276), (1278, 1278), (1280, 1280), (1282, 1282), (1284, 1284), (1286, 1286), (1288, 1288), (1290, 1290), (1292, 1292), (1294, 1294), (1296, 1296), (1298, 1298), (1300, 1300), (1302, 1302), (1304, 1304), (1306, 1306), (1308, 1308), (1310, 1310), (1312, 1312), (1314, 1314), (1316, 1316), (1318, 1318), (1320, 1320), (1322, 1322), (1324, 1324), (1326, 1326), (1329, 1366), (4256, 4293), (4295, 4295), (4301, 4301), (5024, 5109), (7312, 7354), (7357, 7359), (7680, 7680), (7682, 7682), (7684, 7684), (7686, 7686), (7688, 7688), (7690, 7690), (7692, 7692), (7694, 7694), (7696, 7696), (7698, 7698), (7700, 7700), (7702, 7702), (7704, 7704), (7706, 7706), (7708, 7708), (7710, 7710), (7712, 7712), (7714, 7714), (7716, 7716), (7718, 7718), (7720, 7720), (7722, 7722), (7724, 7724), (7726, 7726), (7728, 7728), (7730, 7730), (7732, 7732), (7734, 7734), (7736, 7736), (7738, 7738), (7740, 7740), (7742, 7742), (7744, 7744), (7746, 7746), (7748, 7748), (7750, 7750), (7752, 7752), (7754, 7754), (7756, 7756), (7758, 7758), (7760, 7760), (7762, 7762), (7764, 7764), (7766, 7766), (7768, 7768), (7770, 7770), (7772, 7772), (7774, 7774), (7776, 7776), (7778, 7778), (7780, 7780), (7782, 7782), (7784, 7784), (7786, 7786), (7788, 7788), (7790, 7790), (7792, 7792), (7794, 7794), (7796, 7796), (7798, 7798), (7800, 7800), (7802, 7802), (7804, 7804), (7806, 7806), (7808, 7808), (7810, 7810), (7812, 7812), (7814, 7814), (7816, 7816), (7818, 7818), (7820, 7820), (7822, 7822), (7824, 7824), (7826, 7826), (7828, 7828), (7838, 7838), (7840, 7840), (7842, 7842), (7844, 7844), (7846, 7846), (7848, 7848), (7850, 7850), (7852, 7852), (7854, 7854), (7856, 7856), (7858, 7858), (7860, 7860), (7862, 7862), (7864, 7864), (7866, 7866), (7868, 7868), (7870, 7870), (7872, 7872), (7874, 7874), (7876, 7876), (7878, 7878), (7880, 7880), (7882, 7882), (7884, 7884), (7886, 7886), (7888, 7888), (7890, 7890), (7892, 7892), (7894, 7894), (7896, 7896), (7898, 7898), (7900, 7900), (7902, 7902), (7904, 7904), (7906, 7906), (7908, 7908), (7910, 7910), (7912, 7912), (7914, 7914), (7916, 7916), (7918, 7918), (7920, 7920), (7922, 7922), (7924, 7924), (7926, 7926), (7928, 7928), (7930, 7930), (7932, 7932), (7934, 7934), (7944, 7951), (7960, 7965), (7976, 7983), (7992, 7999), (8008, 8013), (8025, 8025), (8027, 8027), (8029, 8029), (8031, 8031), (8040, 8047), (8120, 8123), (8136, 8139), (8152, 8155), (8168, 8172), (8184, 8187), (8450, 8450), (8455, 8455), (8459, 8461), (8464, 8466), (8469, 8469), (8473, 8477), (8484, 8484), (8486, 8486), (8488, 8488), (8490, 8493), (8496, 8499), (8510, 8511), (8517, 8517), (8544, 8559), (8579, 8579), (9398, 9423), (11264, 11310), (11360, 11360), (11362, 11364), (11367, 11367), (11369, 11369), (11371, 11371), (11373, 11376), (11378, 11378), (11381, 11381), (11390, 11392), (11394, 11394), (11396, 11396), (11398, 11398), (11400, 11400), (11402, 11402), (11404, 11404), (11406, 11406), (11408, 11408), (11410, 11410), (11412, 11412), (11414, 11414), (11416, 11416), (11418, 11418), (11420, 11420), (11422, 11422), (11424, 11424), (11426, 11426), (11428, 11428), (11430, 11430), (11432, 11432), (11434, 11434), (11436, 11436), (11438, 11438), (11440, 11440), (11442, 11442), (11444, 11444), (11446, 11446), (11448, 11448), (11450, 11450), (11452, 11452), (11454, 11454), (11456, 11456), (11458, 11458), (11460, 11460), (11462, 11462), (11464, 11464), (11466, 11466), (11468, 11468), (11470, 11470), (11472, 11472), (11474, 11474), (11476, 11476), (11478, 11478), (11480, 11480), (11482, 11482), (11484, 11484), (11486, 11486), (11488, 11488), (11490, 11490), (11499, 11499), (11501, 11501), (11506, 11506), (42560, 42560), (42562, 42562), (42564, 42564), (42566, 42566), (42568, 42568), (42570, 42570), (42572, 42572), (42574, 42574), (42576, 42576), (42578, 42578), (42580, 42580), (42582, 42582), (42584, 42584), (42586, 42586), (42588, 42588), (42590, 42590), (42592, 42592), (42594, 42594), (42596, 42596), (42598, 42598), (42600, 42600), (42602, 42602), (42604, 42604), (42624, 42624), (42626, 42626), (42628, 42628), (42630, 42630), (42632, 42632), (42634, 42634), (42636, 42636), (42638, 42638), (42640, 42640), (42642, 42642), (42644, 42644), (42646, 42646), (42648, 42648), (42650, 42650), (42786, 42786), (42788, 42788), (42790, 42790), (42792, 42792), (42794, 42794), (42796, 42796), (42798, 42798), (42802, 42802), (42804, 42804), (42806, 42806), (42808, 42808), (42810, 42810), (42812, 42812), (42814, 42814), (42816, 42816), (42818, 42818), (42820, 42820), (42822, 42822), (42824, 42824), (42826, 42826), (42828, 42828), (42830, 42830), (42832, 42832), (42834, 42834), (42836, 42836), (42838, 42838), (42840, 42840), (42842, 42842), (42844, 42844), (42846, 42846), (42848, 42848), (42850, 42850), (42852, 42852), (42854, 42854), (42856, 42856), (42858, 42858), (42860, 42860), (42862, 42862), (42873, 42873), (42875, 42875), (42877, 42878), (42880, 42880), (42882, 42882), (42884, 42884), (42886, 42886), (42891, 42891), (42893, 42893), (42896, 42896), (42898, 42898), (42902, 42902), (42904, 42904), (42906, 42906), (42908, 42908), (42910, 42910), (42912, 42912), (42914, 42914), (42916, 42916), (42918, 42918), (42920, 42920), (42922, 42926), (42928, 42932), (42934, 42934), (42936, 42936), (42938, 42938), (42940, 42940), (42942, 42942), (42946, 42946), (42948, 42951), (42953, 42953), (42997, 42997), (65313, 65338), (66560, 66599), (66736, 66771), (68736, 68786), (71840, 71871), (93760, 93791), (119808, 119833), (119860, 119885), (119912, 119937), (119964, 119964), (119966, 119967), (119970, 119970), (119973, 119974), (119977, 119980), (119982, 119989), (120016, 120041), (120068, 120069), (120071, 120074), (120077, 120084), (120086, 120092), (120120, 120121), (120123, 120126), (120128, 120132), (120134, 120134), (120138, 120144), (120172, 120197), (120224, 120249), (120276, 120301), (120328, 120353), (120380, 120405), (120432, 120457), (120488, 120512), (120546, 120570), (120604, 120628), (120662, 120686), (120720, 120744), (120778, 120778), (125184, 125217), (127280, 127305), (127312, 127337), (127344, 127369),
    )
)
_letterCharClass = _getRegexCharacterClassStringFromCodePointRanges(
    (
        (65, 90), (97, 122), (170, 170), (181, 181), (186, 186), (192, 214), (216, 246), (248, 705), (710, 721), (736, 740), (748, 748), (750, 750), (880, 884), (886, 887), (890, 893), (895, 895), (902, 902), (904, 906), (908, 908), (910, 929), (931, 1013), (1015, 1153), (1162, 1327), (1329, 1366), (1369, 1369), (1376, 1416), (1488, 1514), (1519, 1522), (1568, 1610), (1646, 1647), (1649, 1747), (1749, 1749), (1765, 1766), (1774, 1775), (1786, 1788), (1791, 1791), (1808, 1808), (1810, 1839), (1869, 1957), (1969, 1969), (1994, 2026), (2036, 2037), (2042, 2042), (2048, 2069), (2074, 2074), (2084, 2084), (2088, 2088), (2112, 2136), (2144, 2154), (2208, 2228), (2230, 2247), (2308, 2361), (2365, 2365), (2384, 2384), (2392, 2401), (2417, 2432), (2437, 2444), (2447, 2448), (2451, 2472), (2474, 2480), (2482, 2482), (2486, 2489), (2493, 2493), (2510, 2510), (2524, 2525), (2527, 2529), (2544, 2545), (2556, 2556), (2565, 2570), (2575, 2576), (2579, 2600), (2602, 2608), (2610, 2611), (2613, 2614), (2616, 2617), (2649, 2652), (2654, 2654), (2674, 2676), (2693, 2701), (2703, 2705), (2707, 2728), (2730, 2736), (2738, 2739), (2741, 2745), (2749, 2749), (2768, 2768), (2784, 2785), (2809, 2809), (2821, 2828), (2831, 2832), (2835, 2856), (2858, 2864), (2866, 2867), (2869, 2873), (2877, 2877), (2908, 2909), (2911, 2913), (2929, 2929), (2947, 2947), (2949, 2954), (2958, 2960), (2962, 2965), (2969, 2970), (2972, 2972), (2974, 2975), (2979, 2980), (2984, 2986), (2990, 3001), (3024, 3024), (3077, 3084), (3086, 3088), (3090, 3112), (3114, 3129), (3133, 3133), (3160, 3162), (3168, 3169), (3200, 3200), (3205, 3212), (3214, 3216), (3218, 3240), (3242, 3251), (3253, 3257), (3261, 3261), (3294, 3294), (3296, 3297), (3313, 3314), (3332, 3340), (3342, 3344), (3346, 3386), (3389, 3389), (3406, 3406), (3412, 3414), (3423, 3425), (3450, 3455), (3461, 3478), (3482, 3505), (3507, 3515), (3517, 3517), (3520, 3526), (3585, 3632), (3634, 3635), (3648, 3654), (3713, 3714), (3716, 3716), (3718, 3722), (3724, 3747), (3749, 3749), (3751, 3760), (3762, 3763), (3773, 3773), (3776, 3780), (3782, 3782), (3804, 3807), (3840, 3840), (3904, 3911), (3913, 3948), (3976, 3980), (4096, 4138), (4159, 4159), (4176, 4181), (4186, 4189), (4193, 4193), (4197, 4198), (4206, 4208), (4213, 4225), (4238, 4238), (4256, 4293), (4295, 4295), (4301, 4301), (4304, 4346), (4348, 4680), (4682, 4685), (4688, 4694), (4696, 4696), (4698, 4701), (4704, 4744), (4746, 4749), (4752, 4784), (4786, 4789), (4792, 4798), (4800, 4800), (4802, 4805), (4808, 4822), (4824, 4880), (4882, 4885), (4888, 4954), (4992, 5007), (5024, 5109), (5112, 5117), (5121, 5740), (5743, 5759), (5761, 5786), (5792, 5866), (5873, 5880), (5888, 5900), (5902, 5905), (5920, 5937), (5952, 5969), (5984, 5996), (5998, 6000), (6016, 6067), (6103, 6103), (6108, 6108), (6176, 6264), (6272, 6276), (6279, 6312), (6314, 6314), (6320, 6389), (6400, 6430), (6480, 6509), (6512, 6516), (6528, 6571), (6576, 6601), (6656, 6678), (6688, 6740), (6823, 6823), (6917, 6963), (6981, 6987), (7043, 7072), (7086, 7087), (7098, 7141), (7168, 7203), (7245, 7247), (7258, 7293), (7296, 7304), (7312, 7354), (7357, 7359), (7401, 7404), (7406, 7411), (7413, 7414), (7418, 7418), (7424, 7615), (7680, 7957), (7960, 7965), (7968, 8005), (8008, 8013), (8016, 8023), (8025, 8025), (8027, 8027), (8029, 8029), (8031, 8061), (8064, 8116), (8118, 8124), (8126, 8126), (8130, 8132), (8134, 8140), (8144, 8147), (8150, 8155), (8160, 8172), (8178, 8180), (8182, 8188), (8305, 8305), (8319, 8319), (8336, 8348), (8450, 8450), (8455, 8455), (8458, 8467), (8469, 8469), (8473, 8477), (8484, 8484), (8486, 8486), (8488, 8488), (8490, 8493), (8495, 8505), (8508, 8511), (8517, 8521), (8526, 8526), (8579, 8580), (11264, 11310), (11312, 11358), (11360, 11492), (11499, 11502), (11506, 11507), (11520, 11557), (11559, 11559), (11565, 11565), (11568, 11623), (11631, 11631), (11648, 11670), (11680, 11686), (11688, 11694), (11696, 11702), (11704, 11710), (11712, 11718), (11720, 11726), (11728, 11734), (11736, 11742), (11823, 11823), (12293, 12294), (12337, 12341), (12347, 12348), (12353, 12438), (12445, 12447), (12449, 12538), (12540, 12543), (12549, 12591), (12593, 12686), (12704, 12735), (12784, 12799), (13312, 19903), (19968, 40956), (40960, 42124), (42192, 42237), (42240, 42508), (42512, 42527), (42538, 42539), (42560, 42606), (42623, 42653), (42656, 42725), (42775, 42783), (42786, 42888), (42891, 42943), (42946, 42954), (42997, 43009), (43011, 43013), (43015, 43018), (43020, 43042), (43072, 43123), (43138, 43187), (43250, 43255), (43259, 43259), (43261, 43262), (43274, 43301), (43312, 43334), (43360, 43388), (43396, 43442), (43471, 43471), (43488, 43492), (43494, 43503), (43514, 43518), (43520, 43560), (43584, 43586), (43588, 43595), (43616, 43638), (43642, 43642), (43646, 43695), (43697, 43697), (43701, 43702), (43705, 43709), (43712, 43712), (43714, 43714), (43739, 43741), (43744, 43754), (43762, 43764), (43777, 43782), (43785, 43790), (43793, 43798), (43808, 43814), (43816, 43822), (43824, 43866), (43868, 43881), (43888, 44002), (44032, 55203), (55216, 55238), (55243, 55291), (63744, 64109), (64112, 64217), (64256, 64262), (64275, 64279), (64285, 64285), (64287, 64296), (64298, 64310), (64312, 64316), (64318, 64318), (64320, 64321), (64323, 64324), (64326, 64433), (64467, 64829), (64848, 64911), (64914, 64967), (65008, 65019), (65136, 65140), (65142, 65276), (65313, 65338), (65345, 65370), (65382, 65470), (65474, 65479), (65482, 65487), (65490, 65495), (65498, 65500), (65536, 65547), (65549, 65574), (65576, 65594), (65596, 65597), (65599, 65613), (65616, 65629), (65664, 65786), (66176, 66204), (66208, 66256), (66304, 66335), (66349, 66368), (66370, 66377), (66384, 66421), (66432, 66461), (66464, 66499), (66504, 66511), (66560, 66717), (66736, 66771), (66776, 66811), (66816, 66855), (66864, 66915), (67072, 67382), (67392, 67413), (67424, 67431), (67584, 67589), (67592, 67592), (67594, 67637), (67639, 67640), (67644, 67644), (67647, 67669), (67680, 67702), (67712, 67742), (67808, 67826), (67828, 67829), (67840, 67861), (67872, 67897), (67968, 68023), (68030, 68031), (68096, 68096), (68112, 68115), (68117, 68119), (68121, 68149), (68192, 68220), (68224, 68252), (68288, 68295), (68297, 68324), (68352, 68405), (68416, 68437), (68448, 68466), (68480, 68497), (68608, 68680), (68736, 68786), (68800, 68850), (68864, 68899), (69248, 69289), (69296, 69297), (69376, 69404), (69415, 69415), (69424, 69445), (69552, 69572), (69600, 69622), (69635, 69687), (69763, 69807), (69840, 69864), (69891, 69926), (69956, 69956), (69959, 69959), (69968, 70002), (70006, 70006), (70019, 70066), (70081, 70084), (70106, 70106), (70108, 70108), (70144, 70161), (70163, 70187), (70272, 70278), (70280, 70280), (70282, 70285), (70287, 70301), (70303, 70312), (70320, 70366), (70405, 70412), (70415, 70416), (70419, 70440), (70442, 70448), (70450, 70451), (70453, 70457), (70461, 70461), (70480, 70480), (70493, 70497), (70656, 70708), (70727, 70730), (70751, 70753), (70784, 70831), (70852, 70853), (70855, 70855), (71040, 71086), (71128, 71131), (71168, 71215), (71236, 71236), (71296, 71338), (71352, 71352), (71424, 71450), (71680, 71723), (71840, 71903), (71935, 71942), (71945, 71945), (71948, 71955), (71957, 71958), (71960, 71983), (71999, 71999), (72001, 72001), (72096, 72103), (72106, 72144), (72161, 72161), (72163, 72163), (72192, 72192), (72203, 72242), (72250, 72250), (72272, 72272), (72284, 72329), (72349, 72349), (72384, 72440), (72704, 72712), (72714, 72750), (72768, 72768), (72818, 72847), (72960, 72966), (72968, 72969), (72971, 73008), (73030, 73030), (73056, 73061), (73063, 73064), (73066, 73097), (73112, 73112), (73440, 73458), (73648, 73648), (73728, 74649), (74880, 75075), (77824, 78894), (82944, 83526), (92160, 92728), (92736, 92766), (92880, 92909), (92928, 92975), (92992, 92995), (93027, 93047), (93053, 93071), (93760, 93823), (93952, 94026), (94032, 94032), (94099, 94111), (94176, 94177), (94179, 94179), (94208, 100343), (100352, 101589), (101632, 101640), (110592, 110878), (110928, 110930), (110948, 110951), (110960, 111355), (113664, 113770), (113776, 113788), (113792, 113800), (113808, 113817), (119808, 119892), (119894, 119964), (119966, 119967), (119970, 119970), (119973, 119974), (119977, 119980), (119982, 119993), (119995, 119995), (119997, 120003), (120005, 120069), (120071, 120074), (120077, 120084), (120086, 120092), (120094, 120121), (120123, 120126), (120128, 120132), (120134, 120134), (120138, 120144), (120146, 120485), (120488, 120512), (120514, 120538), (120540, 120570), (120572, 120596), (120598, 120628), (120630, 120654), (120656, 120686), (120688, 120712), (120714, 120744), (120746, 120770), (120772, 120779), (123136, 123180), (123191, 123197), (123214, 123214), (123584, 123627), (124928, 125124), (125184, 125251), (125259, 125259), (126464, 126467), (126469, 126495), (126497, 126498), (126500, 126500), (126503, 126503), (126505, 126514), (126516, 126519), (126521, 126521), (126523, 126523), (126530, 126530), (126535, 126535), (126537, 126537), (126539, 126539), (126541, 126543), (126545, 126546), (126548, 126548), (126551, 126551), (126553, 126553), (126555, 126555), (126557, 126557), (126559, 126559), (126561, 126562), (126564, 126564), (126567, 126570), (126572, 126578), (126580, 126583), (126585, 126588), (126590, 126590), (126592, 126601), (126603, 126619), (126625, 126627), (126629, 126633), (126635, 126651), (131072, 173789), (173824, 177972), (177984, 178205), (178208, 183969), (183984, 191456), (194560, 195101), (196608, 201546),
    )
)
_numericCharClass = _getRegexCharacterClassStringFromCodePointRanges(
    (
        (48, 57), (178, 179), (185, 185), (188, 190), (1632, 1641), (1776, 1785), (1984, 1993), (2406, 2415), (2534, 2543), (2548, 2553), (2662, 2671), (2790, 2799), (2918, 2927), (2930, 2935), (3046, 3058), (3174, 3183), (3192, 3198), (3302, 3311), (3416, 3422), (3430, 3448), (3558, 3567), (3664, 3673), (3792, 3801), (3872, 3891), (4160, 4169), (4240, 4249), (4969, 4988), (5870, 5872), (6112, 6121), (6128, 6137), (6160, 6169), (6470, 6479), (6608, 6618), (6784, 6793), (6800, 6809), (6992, 7001), (7088, 7097), (7232, 7241), (7248, 7257), (8304, 8304), (8308, 8313), (8320, 8329), (8528, 8578), (8581, 8585), (9312, 9371), (9450, 9471), (10102, 10131), (11517, 11517), (12295, 12295), (12321, 12329), (12344, 12346), (12690, 12693), (12832, 12841), (12872, 12879), (12881, 12895), (12928, 12937), (12977, 12991), (13317, 13317), (13443, 13443), (14378, 14378), (15181, 15181), (19968, 19968), (19971, 19971), (19975, 19975), (19977, 19977), (20061, 20061), (20108, 20108), (20116, 20116), (20118, 20118), (20159, 20160), (20191, 20191), (20200, 20200), (20237, 20237), (20336, 20336), (20740, 20740), (20806, 20806), (20841, 20841), (20843, 20843), (20845, 20845), (21313, 21313), (21315, 21317), (21324, 21324), (21441, 21444), (22235, 22235), (22769, 22769), (22777, 22777), (24186, 24186), (24318, 24319), (24332, 24334), (24336, 24336), (25342, 25342), (25420, 25420), (26578, 26578), (28422, 28422), (29590, 29590), (30334, 30334), (32902, 32902), (33836, 33836), (36014, 36014), (36019, 36019), (36144, 36144), (38433, 38433), (38470, 38470), (38476, 38476), (38520, 38520), (38646, 38646), (42528, 42537), (42726, 42735), (43056, 43061), (43216, 43225), (43264, 43273), (43472, 43481), (43504, 43513), (43600, 43609), (44016, 44025), (63851, 63851), (63859, 63859), (63864, 63864), (63922, 63922), (63953, 63953), (63955, 63955), (63997, 63997), (65296, 65305), (65799, 65843), (65856, 65912), (65930, 65931), (66273, 66299), (66336, 66339), (66369, 66369), (66378, 66378), (66513, 66517), (66720, 66729), (67672, 67679), (67705, 67711), (67751, 67759), (67835, 67839), (67862, 67867), (68028, 68029), (68032, 68047), (68050, 68095), (68160, 68168), (68221, 68222), (68253, 68255), (68331, 68335), (68440, 68447), (68472, 68479), (68521, 68527), (68858, 68863), (68912, 68921), (69216, 69246), (69405, 69414), (69457, 69460), (69573, 69579), (69714, 69743), (69872, 69881), (69942, 69951), (70096, 70105), (70113, 70132), (70384, 70393), (70736, 70745), (70864, 70873), (71248, 71257), (71360, 71369), (71472, 71483), (71904, 71922), (72016, 72025), (72784, 72812), (73040, 73049), (73120, 73129), (73664, 73684), (74752, 74862), (92768, 92777), (93008, 93017), (93019, 93025), (93824, 93846), (119520, 119539), (119648, 119672), (120782, 120831), (123200, 123209), (123632, 123641), (125127, 125135), (125264, 125273), (126065, 126123), (126125, 126127), (126129, 126132), (126209, 126253), (126255, 126269), (127232, 127244), (130032, 130041), (131073, 131073), (131172, 131172), (131298, 131298), (131361, 131361), (133418, 133418), (133507, 133507), (133516, 133516), (133532, 133532), (133866, 133866), (133885, 133885), (133913, 133913), (140176, 140176), (141720, 141720), (146203, 146203), (156269, 156269), (194704, 194704),
    )
)
# fmt: on

# These ranges include more than just A-Za-z, but all Unicode characters
# that islower(), isupper(), and isalpha() identify as lowercase, uppercase,
# and alphabetical letter characters.
LETTER = '[' + _letterCharClass + ']'
NONLETTER = '[^' + _letterCharClass + ']'
UPPERCASE = '[' + _uppercaseCharClass + ']'
NONUPPERCASE = '[^' + _uppercaseCharClass + ']'
LOWERCASE = '[' + _lowercaseCharClass + ']'
NONLOWERCASE = '[^' + _lowercaseCharClass + ']'
ALPHANUMERIC = '[' + _numericCharClass + _letterCharClass + ']'
NONALPHANUMERIC = '[^' + _numericCharClass + _letterCharClass + ']'
NUMERIC = '[' + _numericCharClass + ']'
NONNUMERIC = '[^' + _numericCharClass + ']'

del _lowercaseCharClass
del _uppercaseCharClass
del _letterCharClass
del _numericCharClass

"""
# On second thought, I don't think these constants add much. It's easier
# to just use the regex string themselves.
ASCII_LETTER = '[A-Za-z]'
ASCII_NONLETTER = '[^A-Za-z]'
ASCII_UPPERCASE = '[A-Z]'
ASCII_NONUPPERCASE = '[^A-Z]'
ASCII_LOWERCASE = '[a-z]'
ASCII_NONLOWERCASE = '[^a-z]'
ASCII_ALPHANUMERIC = '[A-Za-z0-9]'
ASCII_NONALPHANUMERIC = '[^A-Za-z0-9]'
ASCII_NUMERIC = '[0-9]'
ASCII_NONNUMERIC = '[^0-9]'
"""

HEXADECIMAL = '[0-9A-Fa-f]'
NONHEXADECIMAL = '[^0-9A-Fa-f]'

# Built-in Humre Patterns:
# TODO - I'm still not sure about these names:
ANYTHING = '.*?'
EVERYTHING = '.*'
GREEDY_SOMETHING = '.+'
SOMETHING = '.+?'
ANYCHAR = '.'


# labels for escaped regex metacharacters: . ^ $ * + ? { } [ ] \ | ( )
# This full list copied from https://docs.python.org/3/howto/regex.html
PERIOD = r'\.'
CARET = r'\^'
DOLLAR = r'\$'
ASTERISK = r'\*'
PLUS = r'\+'
MINUS = r'\-'  # NOTE - Not strictly needed, but here since PLUS is.
QUESTION_MARK = r'\?'
OPEN_BRACE = r'\{'
CLOSE_BRACE = r'\}'
OPEN_BRACKET = r'\['
CLOSE_BRACKET = r'\]'
BACKSLASH = r'\\'
PIPE = r'\|'
OPEN_PAREN = OPEN_PARENTHESIS = r'\('
CLOSE_PAREN = CLOSE_PARENTHESIS = r'\)'

NEWLINE = r'\n'  # TODO - double check this: do I want r'\n' or '\n' here?
TAB = r'\t'
QUOTE = r"\'"
DOUBLE_QUOTE = r'\"'

BACK_1 = r'\1'
BACK_2 = r'\2'
BACK_3 = r'\3'
BACK_4 = r'\4'
BACK_5 = r'\5'
BACK_6 = r'\6'
BACK_7 = r'\7'
BACK_8 = r'\8'
BACK_9 = r'\9'


def back_reference(groupNumber):  # type: (int) -> str
    r"""Returns a string in the regex syntax for a back reference, such as
    \1, \2, etc.

    >>> from humre import *
    >>> back_reference(1)
    '\\1'
    >>> back_reference(2)
    '\\2'
    """
    if not isinstance(groupNumber, int):
        raise TypeError('groupNumber must be an integer 1 or greater, not ' + str(type(groupNumber)))
    if groupNumber < 1:
        raise ValueError('groupNumber must be an integer 1 or greater')

    return '\\' + str(groupNumber)


back_ref = back_reference


def join(*args):
    return ''.join(args)


def esc(*tuple_of_regex_strs):  # type: (str) -> str
    r"""A wrapper for re.escape(). Escape special characters in the strings
    in tuple_of_regex_strs.

    >>> from humre import *
    >>> esc('!#$%&')
    '!\\#\\$%\\&'

    >>> import re
    >>> re.escape('!#$%&') == esc('!#$%&')
    True
    """
    return re.escape(''.join(tuple_of_regex_strs))


def compile(*tuple_of_regex_strs, flags=0):  # TODO fix type hint
    """A wrapper for re.compile(). This passes the strings in tuple_of_regex_strs
    as a single concatenated string to re.compile(). All other arguments to
    re.compile() must be passed to the flags keyword argument.

    >>> from humre import *
    >>> patternObj = compile('[a-z]+', flags=IGNORECASE)
    >>> patternObj.search('Hello')
    <re.Match object; span=(0, 5), match='Hello'>
    """
    return re.compile(''.join(tuple_of_regex_strs), flags=flags)


def group(*tuple_of_regex_strs):  # type: (str) -> str
    """Returns a string in the regex syntax for a regex group surrounded by
    parentheses of the regex strings in tuple_of_regex_strs.

    >>> from humre import *
    >>> group('cat')
    '(cat)'
    >>> group('cat', 'dog', 'moose')
    '(catdogmoose)'
    >>> group('catdogmoose')
    '(catdogmoose)'
    >>> group('cat', group('dog'), group('moose'))
    '(cat(dog)(moose))'
    """
    return '(' + ''.join(tuple_of_regex_strs) + ')'


def lookahead(*tuple_of_regex_strs):  # type: (str) -> str
    """Returns a string in the regex syntax for a positive lookahead
    assertion of the regex strings in tuple_of_regex_strs. A lookahead matches
    text but does not consume it in the original parsed text.

    In the following example, 'kitty' is matched but only if 'cat' follows
    'kitty'. Note that the match only includes 'kitty' and not 'kittycat'.

    >>> from humre import *
    >>> 'kitty' + positive_lookahead('cat')
    'kitty(?=cat)'
    >>> compile('kitty' + positive_lookahead('cat')).search('kitty') == None
    True
    >>> compile('kitty' + positive_lookahead('cat')).search('kittycat')
    <re.Match object; span=(0, 5), match='kitty'>
    """
    return '(?=' + ''.join(tuple_of_regex_strs) + ')'


positive_lookahead = lookahead


def negative_lookahead(*tuple_of_regex_strs):  # type: (str) -> str
    """Returns a string in the regex syntax for a negative lookahead
    assertion of the regex strings in tuple_of_regex_strs. A lookahead matches
    text but does not consume it in the original parsed text.

    In the following example, 'kitty' is matched but only if the 'cat'
    does not follow 'kitty'. Note that the match only includes 'kitty' and
    not 'kittycat'.

    >>> from humre import *
    >>> 'kitty' + negative_lookahead('cat')
    'kitty(?!cat)'
    >>> compile('kitty' + negative_lookahead('cat')).search('kitty')
    <re.Match object; span=(0, 5), match='kitty'>
    >>> compile('kitty' + negative_lookahead('cat')).search('kittycat') == None
    True
    """
    return '(?!' + ''.join(tuple_of_regex_strs) + ')'


def lookbehind(*tuple_of_regex_strs):  # type: (str) -> str
    """Returns a string in the regex syntax for a positive lookbehind
    assertion of the regex strings in tuple_of_regex_strs. A lookbehind
    matches text but does not consume it
    in the original parsed text.

    In the following example, 'cat' is matched but only if 'kitty' is before
    'cat'. Note that the match only includes 'cat' and not 'kittycat'.

    >>> from humre import *
    >>> positive_lookbehind('kitty') + 'cat'
    '(?<=kitty)cat'
    >>> compile(positive_lookbehind('kitty') + 'cat').search('kittycat')
    <re.Match object; span=(5, 8), match='cat'>
    >>> compile(positive_lookbehind('kitty') + 'cat').search('cat') == None
    True
    """
    return '(?<=' + ''.join(tuple_of_regex_strs) + ')'


positive_lookbehind = lookbehind


def negative_lookbehind(*tuple_of_regex_strs):  # type: (str) -> str
    """Returns a string in a negative lookbehind assertion of the regex
    strings in tuple_of_regex_strs. A lookbehind matches text but does not
    consume it in the original parsed text.

    In the following example, 'cat' is matched but only if 'kitty' is not
    before 'cat'. Note that the match only includes 'cat' and not 'kittycat'.

    >>> from humre import *
    >>> negative_lookbehind('kitty') + 'cat'
    '(?<!kitty)cat'
    >>> compile(negative_lookbehind('kitty') + 'cat').search('kittycat') == None
    True
    >>> compile(negative_lookbehind('kitty') + 'cat').search('black cat')
    <re.Match object; span=(6, 9), match='cat'>
    """
    return '(?<!' + ''.join(tuple_of_regex_strs) + ')'


def named_group(name, *tuple_of_regex_strs):  # type: (str, str) -> str
    r"""Returns a string in the regex syntax for a named group of the regex
    strings in tuple_of_regex_strs.

    Named groups can be referred to by their name rather than their
    group number.

    >>> from humre import *
    >>> named_group('group_name', 'pattern_to_look_for')
    '(?P<group_name>pattern_to_look_for)'
    >>> named_group('pobox', r'PO BOX \d{3:5}')
    '(?P<pobox>PO BOX \\d{3:5})'
    """
    if re.match(r'\w+', name) is None or re.match(r'^\d', name):
        raise ValueError('name must contain only letters, numbers, and underscore and not start with a number')
    return '(?P<' + str(name) + '>' + ''.join(tuple_of_regex_strs) + ')'


# TODO - is there a better name than this? noncapture()?
def noncap_group(*tuple_of_regex_strs):
    r"""Returns a string in the regex syntax for a noncapturing group of the
    regex strings in tuple_of_regex_strs.

    Noncapturing groups are not included in the groups field of a Pattern
    object. They are useful for when you want to group parts of a regex
    string together without affecting the numbered groups.

    >>> from humre import *
    >>> noncap_group('pattern_to_look_for')
    '(?:pattern_to_look_for)'
    """
    return '(?:' + ''.join(tuple_of_regex_strs) + ')'


def optional(*tuple_of_regex_strs):  # type: (str) -> str
    r"""Returns a string in the regex syntax for an optional part of the
    pattern of the regex strings in tuple_of_regex_strs.

    >>> from humre import *
    >>> optional('a')
    'a?'
    >>> optional(group('spam'))
    '(spam)?'
    """
    regexStr = ''.join(tuple_of_regex_strs)
    if regexStr == '':
        raise ValueError('tuple_of_regex_strs must have at least one nonblank value')
    return regexStr + '?'


# TODO - it's going to be really easy to get this wrong when people pass multiple comma-separated arguments when they intended to pass fewer string arguments in. How do we avoid this problem?
def either(*tuple_of_regex_strs):  # type: (str) -> str
    r"""Returns a string in the regex syntax for the alternation or "or"
    operator of the regex strings in tuple_of_regex_strs. This matches one of
    the strings in tuple_of_regex_strs.

    >>> from humre import *
    >>> either(group('cat'), group('dog'), group('moose'))
    '(cat)|(dog)|(moose)'
    """
    tuple_of_regex_strs = tuple([s for s in tuple_of_regex_strs if s != ''])
    if len(tuple_of_regex_strs) == 0:
        raise ValueError('tuple_of_regex_strs must have at least one nonblank value')
    return '|'.join(tuple_of_regex_strs)


def exactly(quantity, *tuple_of_regex_strs):  # type: (int, str) -> str
    r"""Returns a string in the regex syntax for matching an exact number
    of occurrences of the regex strings in tuple_of_regex_strs.

    >>> from humre import *
    >>> exactly(3, 'A')
    'A{3}'
    >>> compile(exactly(3, 'a')).search('aaaaah!')
    <re.Match object; span=(0, 3), match='aaa'>
    """
    if not isinstance(quantity, int):
        raise TypeError('quantity must be a positive int')
    if quantity < 0:
        raise ValueError('quantity must be a positive int')
    regexStr = ''.join(tuple_of_regex_strs)
    if regexStr == '':
        raise ValueError('tuple_of_regex_strs must have at least one nonblank value')
    return regexStr + '{' + str(quantity) + '}'


def between(minimum, maximum, *tuple_of_regex_strs):  # type: (int, int, str) -> str
    r"""Returns a string in the regex syntax for matching an between the
    minimum and maximum number of occurrences of the regex strings in
    tuple_of_regex_strs.

    >>> from humre import *
    >>> between(3, 5, 'abc')
    'abc{3,5}'
    """
    if not isinstance(minimum, int):
        raise TypeError('minimum must be a positive int')
    if minimum < 0:
        raise ValueError('minimum must be a positive int')
    if not isinstance(maximum, int):
        raise TypeError('maximum must be a positive int')
    if maximum < 0:
        raise ValueError('maximum must be a positive int')
    if minimum > maximum:
        raise ValueError('minimum greater than maximum')
    regexStr = ''.join(tuple_of_regex_strs)
    if regexStr == '':
        raise ValueError('tuple_of_regex_strs must have at least one nonblank value')
    return regexStr + '{' + str(minimum) + ',' + str(maximum) + '}'


def at_least(minimum, *tuple_of_regex_strs):  # type: (int, str) -> str
    r"""Returns a string in the regex syntax for matching a minimum number
    of occurrences of the regex strings in tuple_of_regex_strs.

    >>> from humre import *
    >>> at_least(3, 'abc')
    'abc{3,}'
    """
    if not isinstance(minimum, int):
        raise TypeError('minimum must be a positive int')
    if minimum < 0:
        raise ValueError('minimum must be a positive int')
    regexStr = ''.join(tuple_of_regex_strs)
    if regexStr == '':
        raise ValueError('tuple_of_regex_strs must have at least one nonblank value')
    return regexStr + '{' + str(minimum) + ',}'


def at_most(maximum, *tuple_of_regex_strs):  # type: (int, str) -> str
    r"""Returns a string in the regex syntax for matching a maximum number
    of occurrences of the regex strings in tuple_of_regex_strs.

    >>> from humre import *
    >>> at_most(3, 'abc')
    'abc{,3}'
    """
    if not isinstance(maximum, int):
        raise TypeError('maximum must be a positive int')
    if maximum < 0:
        raise ValueError('maximum must be a positive int')
    regexStr = ''.join(tuple_of_regex_strs)
    if regexStr == '':
        raise ValueError('tuple_of_regex_strs must have at least one nonblank value')
    return regexStr + '{,' + str(maximum) + '}'


def zero_or_more(*tuple_of_regex_strs):  # type: (str) -> str
    r"""Returns a string in the regex syntax for matching zero or more
    occurrences of the regex strings in tuple_of_regex_strs. This does a
    greedy match, which tries to make the largest match possible.

    >>> from humre import *
    >>> zero_or_more('abc')
    'abc*'
    """
    regexStr = ''.join(tuple_of_regex_strs)
    if regexStr == '':
        raise ValueError('tuple_of_regex_strs must have at least one nonblank value')
    return ''.join(tuple_of_regex_strs) + '*'


def zero_or_more_lazy(*tuple_of_regex_strs):  # type: (str) -> str
    r"""Returns a string in the regex syntax for matching zero or more
    occurrences of the regex strings in tuple_of_regex_strs. This does a
    lazy match, which tries to make the smallest match possible.

    >>> from humre import *
    >>> zero_or_more_lazy('abc')
    'abc*?'
    """
    regexStr = ''.join(tuple_of_regex_strs)
    if regexStr == '':
        raise ValueError('tuple_of_regex_strs must have at least one nonblank value')
    return regexStr + '*?'


def one_or_more(*tuple_of_regex_strs):  # type: (str) -> str
    r"""Returns a string in the regex syntax for matching zero or more
    occurrences of the regex strings in tuple_of_regex_strs. This does a
    lazy match, which tries to make the smallest match possible.

    >>> from humre import *
    >>> one_or_more('abc')
    'abc+'
    """
    regexStr = ''.join(tuple_of_regex_strs)
    if regexStr == '':
        raise ValueError('tuple_of_regex_strs must have at least one nonblank value')
    return regexStr + '+'


def one_or_more_lazy(*tuple_of_regex_strs):  # type: (str) -> str
    r"""Returns a string in the regex syntax for matching one or more
    occurrences of the regex strings in tuple_of_regex_strs. This does a
    lazy match, which tries to make the smallest match possible.

    >>> from humre import *
    >>> one_or_more_lazy('abc')
    'abc+?'
    """
    regexStr = ''.join(tuple_of_regex_strs)
    if regexStr == '':
        raise ValueError('tuple_of_regex_strs must have at least one nonblank value')
    return regexStr + '+?'


def starts_with(*tuple_of_regex_strs):  # type: (str) -> str
    r"""Returns a string in the regex syntax for matching the pattern
    of the regex strings in tuple_of_regex_strs at the start of the searched
    text.

    >>> from humre import *
    >>> starts_with('abc')
    '^abc'
    """
    return '^' + ''.join(tuple_of_regex_strs)


def ends_with(*tuple_of_regex_strs):  # type: (str) -> str
    r"""Returns a string in the regex syntax for matching the pattern
    of the regex strings in tuple_of_regex_strs at the end of the searched
    text.
    >>> from humre import *
    >>> ends_with('abc')
    'abc$'
    """
    return ''.join(tuple_of_regex_strs) + '$'


def starts_and_ends_with(*tuple_of_regex_strs):  # type: (str) -> str
    r"""Returns a string in the regex syntax for matching the pattern
    of the regex strings in tuple_of_regex_strs at the start and endof the
    searched text. (That is, the pattern must match the complete searched
    text.)

    >>> from humre import *
    >>> starts_and_ends_with('abc')
    '^abc$'
    """
    return '^' + ''.join(tuple_of_regex_strs) + '$'


def chars(*tuple_of_characters):  # type: (str) -> str
    r"""Returns a string in the regex syntax for a character class including
    the characters in tuple_of_characters.

    >>> from humre import *
    >>> chars('abc')
    '[abc]'
    """
    characters = ''.join(tuple_of_characters)
    if characters == '':
        raise ValueError('tuple_of_characters must have at least one nonblank value')
    return '[' + characters + ']'


def nonchars(*tuple_of_characters):  # type: (str) -> str
    r"""Returns a string in the regex syntax for a character class excluding
    the characters in tuple_of_characters.

    >>> from humre import *
    >>> nonchars('abc')
    '[^abc]'
    """
    characters = ''.join(tuple_of_characters)
    if characters == '':
        raise ValueError('tuple_of_characters must have at least one nonblank value')
    return '[^' + characters + ']'


def optional_group(*tuple_of_regex_strs):  # type: (str) -> str
    r"""Returns a string in the regex syntax for a group of the regex strings
    in tuple_of_regex_strs, and the group is optional.

    >>> from humre import *
    >>> optional_group('abc')
    '(abc)?'
    """
    return '(' + ''.join(tuple_of_regex_strs) + ')?'


def optional_noncap_group(*tuple_of_regex_strs):  # type: (str) -> str
    r"""Returns a string in the regex syntax for a noncapturing group of the
    regex strings in tuple_of_regex_strs, and the group is optional.

    >>> from humre import *
    >>> optional_noncap_group('abc')
    '(?:abc)?'
    """
    return '(?:' + ''.join(tuple_of_regex_strs) + ')?'


def group_either(*tuple_of_regex_strs):  # type: (str) -> str
    r"""Returns a string in the regex syntax for the alternation or "or"
    operator of the patterns in tuple_of_regex_strs, and the alternation
    is placed in a group.

    >>> from humre import *
    >>> group_either('a', 'b', 'c')
    '(a|b|c)'
    """
    tuple_of_regex_strs = tuple([s for s in tuple_of_regex_strs if s != ''])
    return '(' + '|'.join(tuple_of_regex_strs) + ')'


def noncap_group_either(*tuple_of_regex_strs):  # type: (str) -> str
    r"""Returns a string in the regex syntax for the alternation or "or"
    operator of the patterns in tuple_of_regex_strs, and the alternation
    is placed in a noncapturing group.

    >>> from humre import *
    >>> noncap_group_either('a', 'b', 'c')
    '(?:a|b|c)'
    """
    tuple_of_regex_strs = tuple([s for s in tuple_of_regex_strs if s != ''])
    return '(?:' + '|'.join(tuple_of_regex_strs) + ')'


def group_exactly(quantity, *tuple_of_regex_strs):  # type: (int, str) -> str
    r"""Returns a string in the regex syntax for matching an exact number
    of occurrences of the regex strings in tuple_of_regex_strs, placed in a
    group.

    >>> from humre import *
    >>> group_exactly(3, 'abc')
    '(abc){3}'
    """
    if not isinstance(quantity, int):
        raise TypeError('quantity must be a positive int')
    if quantity < 0:
        raise ValueError('quantity must be a positive int')

    return '(' + ''.join(tuple_of_regex_strs) + '){' + str(quantity) + '}'


def noncap_group_exactly(quantity, *tuple_of_regex_strs):  # type: (int, str) -> str
    r"""Returns a string in the regex syntax for matching an exact number
    of occurrences of the regex strings in tuple_of_regex_strs, placed in a
    noncapturing group.

    >>> from humre import *
    >>> noncap_group_exactly(3, 'abc')
    '(?:abc){3}'
    """
    if not isinstance(quantity, int):
        raise TypeError('quantity must be a positive int')
    if quantity < 0:
        raise ValueError('quantity must be a positive int')

    return '(?:' + ''.join(tuple_of_regex_strs) + '){' + str(quantity) + '}'


def group_between(minimum, maximum, *tuple_of_regex_strs):  # type: (int, int, str) -> str
    r"""Returns a string in the regex syntax for matching between a minimum
    and maximum number of occurrences of the regex strings in
    tuple_of_regex_strs, placed in a  group.

    >>> from humre import *
    >>> group_between(3, 5, 'abc')
    '(abc){3,5}'
    """
    if not isinstance(minimum, int):
        raise TypeError('minimum must be a positive int')
    if minimum < 0:
        raise ValueError('minimum must be a positive int')
    if not isinstance(maximum, int):
        raise TypeError('maximum must be a positive int')
    if maximum < 0:
        raise ValueError('maximum must be a positive int')
    if minimum > maximum:
        raise ValueError('minimum greater than maximum')

    return '(' + ''.join(tuple_of_regex_strs) + '){' + str(minimum) + ',' + str(maximum) + '}'


def noncap_group_between(minimum, maximum, *tuple_of_regex_strs):  # type: (int, int, str) -> str
    r"""Returns a string in the regex syntax for matching between a minimum
    and maximum number of occurrences of the regex strings in
    tuple_of_regex_strs, placed in a noncapturing group.

    >>> from humre import *
    >>> noncap_group_between(3, 5, 'abc')
    '(?:abc){3,5}'
    """
    if not isinstance(minimum, int):
        raise TypeError('minimum must be a positive int')
    if minimum < 0:
        raise ValueError('minimum must be a positive int')
    if not isinstance(maximum, int):
        raise TypeError('maximum must be a positive int')
    if maximum < 0:
        raise ValueError('maximum must be a positive int')
    if minimum > maximum:
        raise ValueError('minimum greater than maximum')

    return '(?:' + ''.join(tuple_of_regex_strs) + '){' + str(minimum) + ',' + str(maximum) + '}'


def group_at_least(minimum, *tuple_of_regex_strs):  # type: (int, str) -> str
    r"""Returns a string in the regex syntax for matching a minimum number
    of occurrences of the regex strings in tuple_of_regex_strs, placed in a
    group.

    >>> from humre import *
    >>> group_at_least(3, 'abc')
    '(abc){3,}'
    """
    if not isinstance(minimum, int):
        raise TypeError('minimum must be a positive int')
    if minimum < 0:
        raise ValueError('minimum must be a positive int')

    return '(' + ''.join(tuple_of_regex_strs) + '){' + str(minimum) + ',}'


def noncap_group_at_least(minimum, *tuple_of_regex_strs):  # type: (int, str) -> str
    r"""Returns a string in the regex syntax for matching a minimum number
    of occurrences of the regex strings in tuple_of_regex_strs, placed in a
    noncapturing group.

    >>> from humre import *
    >>> noncap_group_at_least(3, 'abc')
    '(?:abc){3,}'
    """
    if not isinstance(minimum, int):
        raise TypeError('minimum must be a positive int')
    if minimum < 0:
        raise ValueError('minimum must be a positive int')

    return '(?:' + ''.join(tuple_of_regex_strs) + '){' + str(minimum) + ',}'


def group_at_most(maximum, *tuple_of_regex_strs):  # type: (int, str) -> str
    r"""Returns a string in the regex syntax for matching a maximum number
    of occurrences of the regex strings in tuple_of_regex_strs, placed in a
    group.

    >>> from humre import *
    >>> group_at_most(3, 'abc')
    '(abc){,3}'
    """
    if not isinstance(maximum, int):
        raise TypeError('maximum must be a positive int')
    if maximum < 0:
        raise ValueError('maximum must be a positive int')

    return '(' + ''.join(tuple_of_regex_strs) + '){,' + str(maximum) + '}'


def noncap_group_at_most(maximum, *tuple_of_regex_strs):  # type: (int, str) -> str
    r"""Returns a string in the regex syntax for matching a maximum number
    of occurrences of the regex strings in tuple_of_regex_strs, placed in a
    group.

    >>> from humre import *
    >>> noncap_group_at_most(3, 'abc')
    '(?:abc){,3}'
    """
    if not isinstance(maximum, int):
        raise TypeError('maximum must be a positive int')
    if maximum < 0:
        raise ValueError('maximum must be a positive int')

    return '(?:' + ''.join(tuple_of_regex_strs) + '){,' + str(maximum) + '}'


def zero_or_more_group(*tuple_of_regex_strs):  # type: (str) -> str
    r"""Returns a string in the regex syntax for matching zero or more number
    of occurrences of the regex strings in tuple_of_regex_strs, placed in a
    group.

    >>> from humre import *
    >>> zero_or_more_group('abc')
    '(abc)*'
    """
    return '(' + ''.join(tuple_of_regex_strs) + ')*'


def zero_or_more_noncap_group(*tuple_of_regex_strs):  # type: (str) -> str
    r"""Returns a string in the regex syntax for matching zero or more number
    of occurrences of the regex strings in tuple_of_regex_strs, placed in a
    noncapturing group.

    >>> from humre import *
    >>> zero_or_more_noncap_group('abc')
    '(?:abc)*'
    """
    return '(?:' + ''.join(tuple_of_regex_strs) + ')*'


def zero_or_more_lazy_group(*tuple_of_regex_strs):  # type: (str) -> str
    r"""Returns a string in the regex syntax for matching zero or more number
    of occurrences of the regex strings in tuple_of_regex_strs, placed in a
    group. This is a lazy match, so it attempts to make the smallest possible
    match.

    >>> from humre import *
    >>> zero_or_more_lazy_group('abc')
    '(abc)*?'
    """
    return '(' + ''.join(tuple_of_regex_strs) + ')*?'


def zero_or_more_lazy_noncap_group(*tuple_of_regex_strs):  # type: (str) -> str
    r"""Returns a string in the regex syntax for matching zero or more number
    of occurrences of the regex strings in tuple_of_regex_strs, placed in a
    noncapturing group. This is a lazy match, so it attempts to make the
    smallest possible match.

    >>> from humre import *
    >>> zero_or_more_lazy_noncap_group('abc')
    '(?:abc)*?'
    """
    return '(?:' + ''.join(tuple_of_regex_strs) + ')*?'


def one_or_more_group(*tuple_of_regex_strs):  # type: (str) -> str
    r"""Returns a string in the regex syntax for matching one or more number
    of occurrences of the regex strings in tuple_of_regex_strs, placed in a
    group.

    >>> from humre import *
    >>> one_or_more_group('abc')
    '(abc)+'
    """
    return '(' + ''.join(tuple_of_regex_strs) + ')+'


def one_or_more_noncap_group(*tuple_of_regex_strs):  # type: (str) -> str
    r"""Returns a string in the regex syntax for matching one or more number
    of occurrences of the regex strings in tuple_of_regex_strs, placed in a
    noncapturing group.

    >>> from humre import *
    >>> one_or_more_noncap_group('abc')
    '(?:abc)+'
    """
    return '(?:' + ''.join(tuple_of_regex_strs) + ')+'


def one_or_more_lazy_group(*tuple_of_regex_strs):  # type: (str) -> str
    r"""Returns a string in the regex syntax for matching one or more number
    of occurrences of the regex strings in tuple_of_regex_strs, placed in a
    group. This is a lazy match, so it attempts to make the smallest possible
    match.

    >>> from humre import *
    >>> one_or_more_lazy_group('abc')
    '(abc)+?'
    """
    return '(' + ''.join(tuple_of_regex_strs) + ')+?'


def one_or_more_lazy_noncap_group(*tuple_of_regex_strs):  # type: (str) -> str
    r"""Returns a string in the regex syntax for matching one or more number
    of occurrences of the regex strings in tuple_of_regex_strs, placed in a
    noncapturing group. This is a lazy match, so it attempts to make the
    smallest possible match.

    >>> from humre import *
    >>> one_or_more_lazy_noncap_group('abc')
    '(?:abc)+?'
    """
    return '(?:' + ''.join(tuple_of_regex_strs) + ')+?'


def group_chars(*tuple_of_characters):  # type: (str) -> str
    r"""Returns a string in the regex syntax for a character class including
    the characters in tuple_of_characters, and placed in a group.

    >>> from humre import *
    >>> group_chars('abc')
    '([abc])'
    """
    regexStr = ''.join(tuple_of_characters)
    if regexStr == '':
        raise ValueError('tuple_of_characters must have at least one nonblank value')
    return '([' + regexStr + '])'


def noncap_group_chars(*tuple_of_characters):  # type: (str) -> str
    r"""Returns a string in the regex syntax for a character class including
    the characters in tuple_of_characters, and placed in a noncapturing
    group.

    >>> from humre import *
    >>> noncap_group_chars('abc')
    '(?:[abc])'
    """
    regexStr = ''.join(tuple_of_characters)
    if regexStr == '':
        raise ValueError('tuple_of_characters must have at least one nonblank value')
    return '(?:[' + regexStr + '])'


def group_nonchars(*tuple_of_characters):  # type: (str) -> str
    r"""Returns a string in the regex syntax for a character class excluding
    the characters in tuple_of_characters, and placed in a group.

    >>> from humre import *
    >>> group_nonchars('abc')
    '([^abc])'
    """
    regexStr = ''.join(tuple_of_characters)
    if regexStr == '':
        raise ValueError('tuple_of_characters must have at least one nonblank value')
    return '([^' + regexStr + '])'


def noncap_group_nonchars(*tuple_of_characters):  # type: (str) -> str
    r"""Returns a string in the regex syntax for a character class excluding
    the characters in tuple_of_characters, and placed in a noncapturing
    group.

    >>> from humre import *
    >>> noncap_group_nonchars('abc')
    '(?:[^abc])'
    """
    regexStr = ''.join(tuple_of_characters)
    if regexStr == '':
        raise ValueError('tuple_of_characters must have at least one nonblank value')
    return '(?:[^' + regexStr + '])'


# TODO - Are there better names for the atomic group and possessive quantifier functions?
def atomic_group(*tuple_of_regex_strs):  # type: (str) -> str
    r"""Returns a string in the regex syntax for an atomic group of the
    strings in tuple_of_regex_strs. Atomic groups are new in 3.11"""
    return '(?>' + ''.join(tuple_of_regex_strs) + ')'


def zero_or_more_possessive(*tuple_of_regex_strs):  # type: (str) -> str
    r"""Returns a string in the regex syntax for a possessive quantifier
    of zero or more matches of the strings in tuple_of_regex_strs.
    Possessive quantifiers are new in 3.11"""
    regexStr = ''.join(tuple_of_regex_strs)
    if regexStr == '':
        raise ValueError('tuple_of_regex_strs must have at least one nonblank value')
    return ''.join(tuple_of_regex_strs) + '*+'


def one_or_more_possessive(*tuple_of_regex_strs):  # type: (str) -> str
    r"""Returns a string in the regex syntax for a possessive quantifier
    of one or more matches of the strings in tuple_of_regex_strs.
    Possessive quantifiers are new in 3.11"""
    regexStr = ''.join(tuple_of_regex_strs)
    if regexStr == '':
        raise ValueError('tuple_of_regex_strs must have at least one nonblank value')
    return ''.join(tuple_of_regex_strs) + '++'


def optional_possessive(*tuple_of_regex_strs):  # type: (str) -> str
    r"""Returns a string in the regex syntax for a possessive quantifier
    of zero or more matches of the strings in tuple_of_regex_strs.
    Possessive quantifiers are new in 3.11"""
    regexStr = ''.join(tuple_of_regex_strs)
    if regexStr == '':
        raise ValueError('tuple_of_regex_strs must have at least one nonblank value')
    return ''.join(tuple_of_regex_strs) + '?+'


def inline_flag(flags, *tuple_of_regex_strs):  # type: (str, str) -> str
    r"""Returns a string in the regex syntax of the strings in
    tuple_of_regex_strs using inline flags."""
    if not isinstance(flags, str):
        raise TypeError("flags argument must be a str, not " + str(type(flags)))

    for flag in flags:
        if flag not in 'aiLmsux-':
            raise ValueError("flags argument is limited to the characters aiLmsux-")

    mutuallyExclusiveFlagsCount = 0
    if 'a' in flags:
        mutuallyExclusiveFlagsCount += 1
    if 'L' in flags:
        mutuallyExclusiveFlagsCount += 1
    if 'u' in flags:
        mutuallyExclusiveFlagsCount += 1
    if mutuallyExclusiveFlagsCount > 1:
        raise ValueError("flags argument can only have at most one of 'a', 'L', and 'u'' flags")
    return '(?' + flags + ':' + ''.join(tuple_of_regex_strs) + ')'


# More built-in Humre patterns:
NUMBER = ''.join(
    (
        # optional negative or positive sign:
        optional(noncap_group(either(PLUS, '-'))),
        # whole number section:
        noncap_group(
            either(
                # number with commas:
                noncap_group(between(1, 3, DIGIT), one_or_more(noncap_group(',', exactly(3, DIGIT)))),
                # number without commas:
                one_or_more(DIGIT),
            )
        ),
        # fractional number section (optional)
        optional(noncap_group(PERIOD, one_or_more(DIGIT))),
    )
)

EURO_NUMBER = ''.join(
    (
        # optional negative or positive sign:
        optional(noncap_group(either(PLUS, '-'))),
        # whole number section:
        noncap_group(
            either(
                # number with commas:
                noncap_group(between(1, 3, DIGIT), one_or_more(noncap_group(PERIOD, exactly(3, DIGIT)))),
                # number without commas:
                one_or_more(DIGIT),
            )
        ),
        # fractional number section (optional)
        optional(noncap_group(',', one_or_more(DIGIT))),
    )
)

HEXADECIMAL_NUMBER = either(
    noncap_group(noncap_group(either('0x', '0X')), one_or_more(chars('0-9a-f'))),
    noncap_group(noncap_group(either('0x', '0X')), one_or_more(chars('0-9A-F'))),
    noncap_group(one_or_more(chars('0-9a-f'))),
    noncap_group(one_or_more(chars('0-9A-F'))),
)


if __name__ == "__main__":
    import doctest

    doctest.testmod()

'''
# Testing string concatenation vs join() string method:

def group1(*tuple_of_regex_strs):  # type: (str) -> str
    return '(' + ''.join(tuple_of_regex_strs) + ')'
def group2(*tuple_of_regex_strs):  # type: (str) -> str
    return ''.join(['(', ''.join(tuple_of_regex_strs), ')'])
def group3(*tuple_of_regex_strs):  # type: (str) -> str
    return ''.join(['(', *tuple_of_regex_strs, ')'])
def group4(*tuple_of_regex_strs):  # type: (str) -> str
    return ''.join(('(', *tuple_of_regex_strs, ')'))
import timeit
print(timeit.timeit("group1('cat', 'dog')", globals=globals(), number=100000000))
print(timeit.timeit("group2('cat', 'dog')", globals=globals(), number=100000000))
print(timeit.timeit("group3('cat', 'dog')", globals=globals(), number=100000000))
print(timeit.timeit("group4('cat', 'dog')", globals=globals(), number=100000000))
print(timeit.timeit("group1('cat', 'dog', 'cat', 'dog', 'cat', 'dog', 'cat', 'dog', 'cat', 'dog')", globals=globals(), number=100000000))
print(timeit.timeit("group2('cat', 'dog', 'cat', 'dog', 'cat', 'dog', 'cat', 'dog', 'cat', 'dog')", globals=globals(), number=100000000))
print(timeit.timeit("group3('cat', 'dog', 'cat', 'dog', 'cat', 'dog', 'cat', 'dog', 'cat', 'dog')", globals=globals(), number=100000000))
print(timeit.timeit("group4('cat', 'dog', 'cat', 'dog', 'cat', 'dog', 'cat', 'dog', 'cat', 'dog')", globals=globals(), number=100000000))
# Times:
#32.36761399998795
#36.67457259999355
#34.13985800003866
#39.810779399995226
#49.031997100042645
#50.96271799999522
#53.6757457999629
#60.84193440002855
'''
